from aiogram import Router, F, types
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from utils.problem2states import Problem2States
from utils.validators import validate_input_float

from keyboards import reply

router = Router()


@router.message(F.text.lower().in_(["2 –∑–∞–¥–∞—á–∞"]))
async def handle_problem2(message: Message, state: FSMContext):
    await message.answer("–í—ã –≤—ã–±—Ä–∞–ª–∏ –∑–∞–¥–∞—á—É –ø–æ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—é —Ç–æ—á–∫–∏ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—èü•à\n"
                         "–ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –í—ã –≤–≤–µ–¥–µ—Ç–µ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –í—ã –ø–æ–ª—É—á–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ü–µ–Ω—ã —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è, –æ–±—ä–µ–º–∞ —Å–ø—Ä–æ—Å–∞ –∏ –æ–±—ä–µ–º–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.\n"
                         "–í–≤–µ–¥–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç A:")
    await state.set_state(Problem2States.InputA)


@router.message(Problem2States.InputA)
async def input_a(message: types.Message, state: FSMContext):
    # if await validate_input_float(message, state, 'A'):
    try:
        A = float(message.text)
        await state.update_data(A=A)
        await message.answer("–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç B:")
        await state.set_state(Problem2States.InputB)
    except ValueError:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")


@router.message(Problem2States.InputB)
async def input_b(message: types.Message, state: FSMContext):
    # if await validate_input_float(message, state, 'B'):
    try:
        B = float(message.text)
        await state.update_data(B=B)
        await message.answer("–ü—Ä–µ–∫—Ä–∞—Å–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç C:")
        await state.set_state(Problem2States.InputC)
    except ValueError:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")


@router.message(Problem2States.InputC)
async def input_c(message: types.Message, state: FSMContext):
    # if await validate_input_float(message, state, 'C'):
    try:
        C = float(message.text)
        await state.update_data(C=C)
        await message.answer("–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç D:")
        await state.set_state(Problem2States.InputD)
    except ValueError:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")


@router.message(Problem2States.InputD)
async def input_d(message: types.Message, state: FSMContext):
    # if await validate_input_float(message, state, 'D'):
    try:
        D = float(message.text)
        await state.update_data(D=D)

        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        data = await state.get_data()

        # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ –ø–æ —Ñ–æ—Ä–º—É–ª–∞–º —Å–ø—Ä–æ—Å–∞ –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
        P = (data['C'] - data['A']) / (data['B'] + data['D'])
        Qd = data['A'] * P - data['B']
        Qs = data['C'] - data['D'] * P

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        await message.answer(f"–¶–µ–Ω–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è: {P:.2f}\n"
                             f"–û–±—ä–µ–º —Å–ø—Ä–æ—Å–∞: {Qd:.2f}\n"
                             f"–û–±—ä–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {Qs:.2f}", reply_markup=reply.main)

        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        await state.clear()
    except ValueError:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")
